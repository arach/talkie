<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Talkie Terminal</title>
    <link rel="stylesheet" href="xterm.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
        }
        #terminal {
            width: 100%;
            height: 100%;
        }
        /* Custom scrollbar */
        .xterm-viewport::-webkit-scrollbar {
            width: 8px;
        }
        .xterm-viewport::-webkit-scrollbar-track {
            background: transparent;
        }
        .xterm-viewport::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
        }
        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }
    </style>
</head>
<body>
    <div id="terminal"></div>

    <script src="xterm.js"></script>
    <script src="addon-fit.js"></script>
    <script src="addon-web-links.js"></script>
    <script src="addon-webgl.js"></script>

    <script>
        // Initialize terminal with Talkie-style theme
        const term = new Terminal({
            fontFamily: 'SF Mono, Menlo, Monaco, monospace',
            fontSize: 12,
            lineHeight: 1.2,
            cursorBlink: true,
            cursorStyle: 'bar',
            theme: {
                background: '#1a1a1a',
                foreground: '#e0e0e0',
                cursor: '#ffffff',
                cursorAccent: '#1a1a1a',
                selectionBackground: 'rgba(255, 255, 255, 0.2)',
                selectionForeground: '#ffffff',
                // ANSI colors
                black: '#1a1a1a',
                red: '#ff6b6b',
                green: '#69db7c',
                yellow: '#ffd43b',
                blue: '#74c0fc',
                magenta: '#da77f2',
                cyan: '#66d9e8',
                white: '#e0e0e0',
                brightBlack: '#555555',
                brightRed: '#ff8787',
                brightGreen: '#8ce99a',
                brightYellow: '#ffe066',
                brightBlue: '#a5d8ff',
                brightMagenta: '#e599f7',
                brightCyan: '#99e9f2',
                brightWhite: '#ffffff'
            },
            allowProposedApi: true,
            scrollback: 10000,
            convertEol: true
        });

        // Load addons
        const fitAddon = new FitAddon.FitAddon();
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();

        term.loadAddon(fitAddon);
        term.loadAddon(webLinksAddon);

        // Try WebGL for GPU acceleration, fall back to canvas
        try {
            const webglAddon = new WebglAddon.WebglAddon();
            webglAddon.onContextLoss(e => {
                webglAddon.dispose();
            });
            term.loadAddon(webglAddon);
            console.log('WebGL renderer active');
        } catch (e) {
            console.log('WebGL not available, using canvas renderer');
        }

        // Open terminal in container
        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        // Handle resize
        const resizeObserver = new ResizeObserver(() => {
            fitAddon.fit();
            // Notify Swift of new size
            const dims = { cols: term.cols, rows: term.rows };
            window.webkit?.messageHandlers?.terminalResize?.postMessage(dims);
        });
        resizeObserver.observe(document.getElementById('terminal'));

        // Send keyboard input to Swift
        term.onData(data => {
            window.webkit?.messageHandlers?.terminalInput?.postMessage(data);
        });

        // Handle binary data (for things like Ctrl+C)
        term.onBinary(data => {
            window.webkit?.messageHandlers?.terminalInput?.postMessage(data);
        });

        // Handle title changes
        term.onTitleChange(title => {
            window.webkit?.messageHandlers?.terminalTitle?.postMessage(title);
        });

        // API for Swift to call
        window.terminalAPI = {
            // Write output from PTY to terminal
            write: function(data) {
                term.write(data);
            },

            // Write base64-encoded data (for binary safety)
            writeBase64: function(base64) {
                const bytes = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
                term.write(bytes);
            },

            // Clear terminal
            clear: function() {
                term.clear();
            },

            // Reset terminal
            reset: function() {
                term.reset();
            },

            // Focus terminal
            focus: function() {
                term.focus();
            },

            // Resize terminal
            resize: function(cols, rows) {
                term.resize(cols, rows);
            },

            // Fit to container
            fit: function() {
                fitAddon.fit();
                return { cols: term.cols, rows: term.rows };
            },

            // Get current dimensions
            getDimensions: function() {
                return { cols: term.cols, rows: term.rows };
            },

            // Scroll to bottom
            scrollToBottom: function() {
                term.scrollToBottom();
            },

            // Copy selection to clipboard
            copySelection: function() {
                const selection = term.getSelection();
                if (selection) {
                    navigator.clipboard.writeText(selection);
                    return true;
                }
                return false;
            },

            // Paste from clipboard
            paste: function(text) {
                term.paste(text);
            },

            // Select all
            selectAll: function() {
                term.selectAll();
            }
        };

        // Notify Swift that terminal is ready
        window.webkit?.messageHandlers?.terminalReady?.postMessage({
            cols: term.cols,
            rows: term.rows
        });

        // Initial focus
        term.focus();
    </script>
</body>
</html>
