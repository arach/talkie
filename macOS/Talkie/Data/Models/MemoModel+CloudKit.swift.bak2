//
//  MemoModel+CloudKit.swift
//  Talkie
//
//  CloudKit sync adapter for MemoModel
//  Converts between local MemoModel and CloudKit CKRecord
//

import Foundation
import CloudKit

extension MemoModel {
    // MARK: - CloudKit Record Type

    static let cloudKitRecordType = "VoiceMemo"
    static let cloudKitZoneID = CKRecordZone.ID(zoneName: "TalkieMemos", ownerName: CKCurrentUserDefaultName)

    // MARK: - To CloudKit Record

    func toCKRecord() -> CKRecord {
        let recordID = CKRecord.ID(recordName: id.uuidString, zoneID: Self.cloudKitZoneID)
        let record = CKRecord(recordType: Self.cloudKitRecordType, recordID: recordID)

        // Core properties
        record["createdAt"] = createdAt as CKRecordValue
        record["lastModified"] = lastModified as CKRecordValue
        record["title"] = (title ?? "") as CKRecordValue
        record["duration"] = duration as CKRecordValue
        record["sortOrder"] = sortOrder as CKRecordValue

        // Content
        record["transcription"] = (transcription ?? "") as CKRecordValue
        record["notes"] = (notes ?? "") as CKRecordValue
        record["summary"] = (summary ?? "") as CKRecordValue
        record["tasks"] = (tasks ?? "") as CKRecordValue
        record["reminders"] = (reminders ?? "") as CKRecordValue

        // Audio (store as CKAsset)
        if let audioPath = audioFilePath {
            let audioURL = Self.audioStorageURL(for: audioPath)
            if FileManager.default.fileExists(atPath: audioURL.path) {
                let asset = CKAsset(fileURL: audioURL)
                record["audioAsset"] = asset
            }
        }

        // Waveform data
        if let waveform = waveformData {
            record["waveformData"] = waveform as CKRecordValue
        }

        // Processing state
        record["isTranscribing"] = isTranscribing as CKRecordValue
        record["isProcessingSummary"] = isProcessingSummary as CKRecordValue
        record["isProcessingTasks"] = isProcessingTasks as CKRecordValue
        record["isProcessingReminders"] = isProcessingReminders as CKRecordValue
        record["autoProcessed"] = autoProcessed as CKRecordValue

        // Provenance
        record["originDeviceId"] = (originDeviceId ?? "") as CKRecordValue
        if let macReceived = macReceivedAt {
            record["macReceivedAt"] = macReceived as CKRecordValue
        }

        record["pendingWorkflowIds"] = (pendingWorkflowIds ?? "") as CKRecordValue

        return record
    }

    // MARK: - From CloudKit Record

    static func fromCKRecord(_ record: CKRecord) -> MemoModel? {
        guard let idString = record.recordID.recordName,
              let id = UUID(uuidString: idString),
              let createdAt = record["createdAt"] as? Date,
              let lastModified = record["lastModified"] as? Date else {
            return nil
        }

        let title = record["title"] as? String
        let duration = record["duration"] as? Double ?? 0
        let sortOrder = record["sortOrder"] as? Int ?? 0

        let transcription = record["transcription"] as? String
        let notes = record["notes"] as? String
        let summary = record["summary"] as? String
        let tasks = record["tasks"] as? String
        let reminders = record["reminders"] as? String

        // Handle audio asset
        var audioFilePath: String?
        if let audioAsset = record["audioAsset"] as? CKAsset,
           let assetURL = audioAsset.fileURL {
            // Download and save audio file
            audioFilePath = saveAudioAsset(assetURL, memoId: id)
        }

        let waveformData = record["waveformData"] as? Data

        let isTranscribing = record["isTranscribing"] as? Bool ?? false
        let isProcessingSummary = record["isProcessingSummary"] as? Bool ?? false
        let isProcessingTasks = record["isProcessingTasks"] as? Bool ?? false
        let isProcessingReminders = record["isProcessingReminders"] as? Bool ?? false
        let autoProcessed = record["autoProcessed"] as? Bool ?? false

        let originDeviceId = record["originDeviceId"] as? String
        let macReceivedAt = record["macReceivedAt"] as? Date
        let pendingWorkflowIds = record["pendingWorkflowIds"] as? String

        return MemoModel(
            id: id,
            createdAt: createdAt,
            lastModified: lastModified,
            title: title,
            duration: duration,
            sortOrder: sortOrder,
            transcription: transcription,
            notes: notes,
            summary: summary,
            tasks: tasks,
            reminders: reminders,
            audioFilePath: audioFilePath,
            waveformData: waveformData,
            isTranscribing: isTranscribing,
            isProcessingSummary: isProcessingSummary,
            isProcessingTasks: isProcessingTasks,
            isProcessingReminders: isProcessingReminders,
            autoProcessed: autoProcessed,
            originDeviceId: originDeviceId,
            macReceivedAt: macReceivedAt,
            cloudSyncedAt: Date(),  // Mark as synced
            pendingWorkflowIds: pendingWorkflowIds
        )
    }

    // MARK: - Audio Helpers

    private static func audioStorageURL(for relativePath: String) -> URL {
        let appSupport = FileManager.default.urls(
            for: .applicationSupportDirectory,
            in: .userDomainMask
        )[0]
        return appSupport
            .appendingPathComponent("Talkie/Audio", isDirectory: true)
            .appendingPathComponent(relativePath)
    }

    private static func saveAudioAsset(_ assetURL: URL, memoId: UUID) -> String {
        let fileName = "\(memoId.uuidString).m4a"
        let destinationURL = audioStorageURL(for: fileName)

        // Copy file
        try? FileManager.default.copyItem(at: assetURL, to: destinationURL)

        return fileName
    }
}
